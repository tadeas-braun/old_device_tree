#       modified:   Android.mk
#       modified:   extendedcommands.c
#       modified:   recovery.c
#       modified:   ui.c
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       adefines.h
diff --git a/bootable/recovery/Android.mk b/bootable/recovery/Android.mk
index 9b66f54..586957d 100644
--- a/bootable/recovery/Android.mk
+++ b/bootable/recovery/Android.mk
@@ -44,6 +44,19 @@ RECOVERY_NAME := CWM-based Recovery
 endif
 endif
 
+ifeq ($(TARGET_PRODUCT),cm_lotus)
+  LOCAL_CFLAGS += -DXPERIA_GO
+endif
+ifeq ($(TARGET_PRODUCT),cm_pepper)
+  LOCAL_CFLAGS += -DXPERIA_SOLA
+endif
+ifeq ($(TARGET_PRODUCT),cm_kumquat)
+  LOCAL_CFLAGS += -DXPERIA_U
+endif
+ifeq ($(TARGET_PRODUCT),cm_nypon)
+  LOCAL_CFLAGS += -DXPERIA_P
+endif
+
 RECOVERY_VERSION := $(RECOVERY_NAME) v6.0.4.4
 
 LOCAL_CFLAGS += -DRECOVERY_VERSION="$(RECOVERY_VERSION)"
diff --git a/bootable/recovery/extendedcommands.c b/bootable/recovery/extendedcommands.c
index 00c1660..ccc58bc 100644
--- a/bootable/recovery/extendedcommands.c
+++ b/bootable/recovery/extendedcommands.c
@@ -32,6 +32,7 @@
 #include "recovery_ui.h"
 
 #include "extendedcommands.h"
+#include "adefines.h"
 #include "nandroid.h"
 #include "mounts.h"
 #include "flashutils/flashutils.h"
@@ -510,28 +511,96 @@ static int control_usb_storage(bool on)
 
 void show_mount_usb_storage_menu()
 {
-    // Enable USB storage using vold
-    if (!control_usb_storage(true))
-        return;
+    static char lun_command_enable_int[100];
+    static char lun_command_disable_int[100];
+    static char lun_command_enable_ext[100];
+    static char lun_command_disable_ext[100];
+
+    snprintf(lun_command_enable_int, sizeof(lun_command_enable_int), "/sbin/echo \"%s\" > %s", BOARD_VOLD_SDCARD_VOLUME_INT, BOARD_UMS_LUNFILE);
+    snprintf(lun_command_disable_int, sizeof(lun_command_disable_int), "/sbin/echo \"\" > %s", BOARD_UMS_LUNFILE);
+    snprintf(lun_command_enable_ext, sizeof(lun_command_enable_ext), "/sbin/echo \"%s\" > %s", BOARD_VOLD_SDCARD_VOLUME_EXT, BOARD_UMS_LUNFILE);
+    snprintf(lun_command_disable_ext, sizeof(lun_command_disable_ext), "/sbin/echo \"\" > %s", BOARD_UMS_LUNFILE);
 
-    static const char* headers[] = {  "USB Mass Storage device",
-                                "Leaving this menu unmounts",
-                                "your SD card from your PC.",
+    static char* sdheaders[] = {  "SD card mounts",
                                 "",
                                 NULL
     };
 
-    static char* list[] = { "Unmount", NULL };
+    static char* sdlist[] = { "Mount int SD",
+#ifdef HAVE_EXTERNAL_SDCARD
+                            "Mount ext SD",
+#endif
+                            NULL
+    };
 
     for (;;)
     {
-        int chosen_item = get_menu_selection(headers, list, 0, 0);
-        if (chosen_item == GO_BACK || chosen_item == 0)
+        int chosen_item = get_menu_selection(sdheaders, sdlist, 0, 0);
+        if (chosen_item == GO_BACK)
             break;
-    }
+        switch (chosen_item)
+        {
+            case 0:
+            {
+                // Enable USB storage using vold
+                if (!control_usb_storage(true))
+                    return;
+
+                static const char* headers[] = {  "USB Mass Storage device",
+                                           "Leaving this menu unmounts",
+                                           "your int SD card from your PC.",
+                                            "",
+                                            NULL
+                };
+
+                __system(lun_command_enable_int);
+                static char* list[] = { "Unmount", NULL };
+
+                for (;;)
+                {
+                    int chosen_item = get_menu_selection(headers, list, 0, 0);
+                    if (chosen_item == GO_BACK || chosen_item == 0)
+                        break;
+                }
 
-    // Disable USB storage
-    control_usb_storage(false);
+                // Disable USB storage
+
+                __system(lun_command_disable_int);
+                control_usb_storage(false);
+                break;
+            }
+#ifdef HAVE_EXTERNAL_SDCARD
+            case 1:
+            {
+                // Enable USB storage using vold
+                if (!control_usb_storage(true))
+                    return;
+
+                static const char* headers[] = {  "USB Mass Storage device",
+                                           "Leaving this menu unmounts",
+                                           "your ext SD card from your PC.",
+                                            "",
+                                            NULL
+                };
+
+                __system(lun_command_enable_ext);
+                static char* list[] = { "Unmount", NULL };
+
+                for (;;)
+                {
+                    int chosen_item = get_menu_selection(headers, list, 0, 0);
+                    if (chosen_item == GO_BACK || chosen_item == 0)
+                        break;
+                }
+
+                // Disable USB storage
+                __system(lun_command_disable_ext);
+                control_usb_storage(false);
+                break;
+            }
+#endif
+        }
+    }
 }
 
 int confirm_selection(const char* title, const char* confirm)
diff --git a/bootable/recovery/recovery.c b/bootable/recovery/recovery.c
index fbbb06b..ea31d6a 100644
--- a/bootable/recovery/recovery.c
+++ b/bootable/recovery/recovery.c
@@ -776,6 +776,7 @@ wipe_data(int confirm) {
     }
     erase_volume("/sd-ext");
     erase_volume(get_android_secure_path());
+    ui_set_background(BACKGROUND_ICON_CLOCKWORK);
     ui_print("Data wipe complete.\n");
 }
 
diff --git a/bootable/recovery/ui.c b/bootable/recovery/ui.c
index a0dc289..f74eb0b 100644
--- a/bootable/recovery/ui.c
+++ b/bootable/recovery/ui.c
@@ -33,6 +33,7 @@
 #include <cutils/properties.h>
 #include "minui/minui.h"
 #include "recovery_ui.h"
+#include "adefines.h"
 #include "voldclient/voldclient.h"
 
 extern int __system(const char *command);
@@ -44,7 +45,15 @@ static int gShowBackButton = 0;
 #endif
 
 #define MAX_COLS 96
+#ifdef XPERIA_CWM_TOUCH
+  #ifdef XPERIA_GO
+    #define MAX_ROWS 20
+  #else
+    #define MAX_ROWS 28
+  #endif
+#else
 #define MAX_ROWS 32
+#endif
 
 #define MENU_MAX_COLS 64
 #define MENU_MAX_ROWS 250
@@ -87,7 +96,22 @@ static const struct { gr_surface* surface; const char *name; } BITMAPS[] = {
     { &gBackgroundIcon[BACKGROUND_ICON_FIRMWARE_ERROR], "icon_firmware_error" },
     { &gProgressBarEmpty,               "progress_empty" },
     { &gProgressBarFill,                "progress_fill" },
+#ifndef XPERIA_CWM_TOUCH
     { &gBackground,                "stitch" },
+#else
+#ifdef XPERIA_GO
+    { &gBackground,                "stitch_go" },
+#endif
+#ifdef XPERIA_P
+    { &gBackground,                "stitch_p" },
+#endif
+#ifdef XPERIA_SOLA
+    { &gBackground,                "stitch_sola" },
+#endif
+#ifdef XPERIA_U
+    { &gBackground,                "stitch_u" },
+#endif
+#endif
     { NULL,                             NULL },
 };
 
@@ -209,7 +233,11 @@ static void draw_progress_locked()
         int height = gr_get_height(gProgressBarEmpty);
 
         int dx = (gr_fb_width() - width)/2;
+#ifndef XPERIA_CWM_TOUCH
         int dy = (3*gr_fb_height() + iconHeight - 2*height)/4;
+#else
+        int dy = ((3 * gr_fb_height()) + height) / 4;
+#endif
 
         // Erase behind the progress bar (in case this was a progress-only update)
         gr_color(0, 0, 0, 255);
@@ -304,6 +332,10 @@ static void draw_screen_locked(void)
         }
 
         gr_color(NORMAL_TEXT_COLOR);
+#ifdef XPERIA_CWM_TOUCH
+        for (; row < text_rows; ++row) {
+            draw_text_line(row+1, text[(row+text_top) % text_rows]);
+#else
         int cur_row = text_row;
         int available_rows = total_rows - row - 1;
         int start_row = row + 1;
@@ -315,6 +347,7 @@ static void draw_screen_locked(void)
         int r;
         for (r = 0; r < (available_rows < MAX_ROWS ? available_rows : MAX_ROWS); r++) {
             draw_text_line(start_row + r, text[(cur_row + r) % MAX_ROWS]);
+#endif
         }
     }
 }
@@ -355,8 +388,12 @@ static void *progress_thread(void *cookie)
         // update the installation animation, if active
         // skip this if we have a text overlay (too expensive to update)
         if (gCurrentIcon == BACKGROUND_ICON_INSTALLING &&
+#ifndef CWM_INST_ANIM
             ui_parameters.installing_frames > 0 &&
             !show_text) {
+#else
+            ui_parameters.installing_frames > 0) {
+#endif
             gInstallingFrame =
                 (gInstallingFrame + 1) % ui_parameters.installing_frames;
             redraw = 1;
@@ -364,7 +401,11 @@ static void *progress_thread(void *cookie)
 
         // update the progress bar animation, if active
         // skip this if we have a text overlay (too expensive to update)
+#ifndef CWM_INST_ANIM
         if (gProgressBarType == PROGRESSBAR_TYPE_INDETERMINATE && !show_text) {
+#else
+        if (gProgressBarType == PROGRESSBAR_TYPE_INDETERMINATE) {
+#endif
             redraw = 1;
         }
 
@@ -393,12 +434,23 @@ static void *progress_thread(void *cookie)
 }
 
 static int rel_sum = 0;
+#ifdef XPERIA_CWM_TOUCH
+int touch_x = 0;
+int touch_y = 0;
+int rcnt = 0;
+int touch_released = 1;
+#endif
 
 static int input_callback(int fd, short revents, void *data)
 {
     struct input_event ev;
     int ret;
     int fake_key = 0;
+#ifdef XPERIA_CWM_TOUCH
+    int touch_val_x;
+    int touch_val_y;
+    int button_sz;
+#endif
 
     ret = ev_get_input(fd, revents, &ev);
     if (ret)
@@ -414,6 +466,21 @@ static int input_callback(int fd, short revents, void *data)
 #endif
 
     if (ev.type == EV_SYN) {
+#ifdef XPERIA_CWM_TOUCH
+        if (ev.code == SYN_MT_REPORT) {
+            rcnt += 1;
+            if (rcnt >= 2) {
+                rcnt = 0;
+                touch_released = 1;
+            } else {
+                if (!touch_x && !touch_y) {
+                    touch_released = 1;
+                }
+                touch_x = 0;
+                touch_y = 0;
+            }
+        }
+#endif
         return 0;
     } else if (ev.type == EV_REL) {
         if (ev.code == REL_Y) {
@@ -440,6 +507,75 @@ static int input_callback(int fd, short revents, void *data)
         rel_sum = 0;
     }
 
+#ifdef XPERIA_CWM_TOUCH
+    if (ev.type == EV_ABS) {
+            rcnt = 0;
+            if (ev.code == ABS_MT_POSITION_X)
+                touch_x = ev.value;
+            if (ev.code == ABS_MT_POSITION_Y)
+                touch_y = ev.value;
+            if (ev.code == ABS_MT_DISTANCE)
+                ev.code = 0;
+            if (touch_x && touch_y && touch_released) {
+                button_sz = (gr_fb_width() / 7); //4 buttons + 3 spaces with same size like button
+                //ui_print("%d %d %d\n", touch_x, touch_y, button_sz);
+                if (touch_x >= (gr_fb_width()-(7*button_sz)) && touch_x <= (gr_fb_width()-(6*button_sz)))
+                    touch_val_x = 1;
+                else if (touch_x >= (gr_fb_width()-(5*button_sz)) && touch_x <= (gr_fb_width()-(4*button_sz)))
+                    touch_val_x = 2;
+                else if (touch_x >= (gr_fb_width()-(3*button_sz)) && touch_x <= (gr_fb_width()-(2*button_sz)))
+                    touch_val_x = 3;
+                else if (touch_x >= (gr_fb_width()-button_sz) && touch_x <= gr_fb_width())
+                    touch_val_x = 4;
+                else
+                    touch_val_x = 0;
+
+#ifdef XPERIA_GO
+      if (touch_y >= (gr_fb_height()-50) && touch_y <= gr_fb_height())
+#else
+      if (touch_y >= (gr_fb_height()-75) && touch_y <= gr_fb_height())
+#endif
+                    touch_val_y = 1;
+                else
+                    touch_val_y = 0;
+
+                switch (touch_val_x) {
+                    case 1:
+                        if (touch_val_y) {
+                            ev.type = EV_KEY;
+                            ev.code = KEY_UP;
+                            ev.value = 1;
+                        }
+                        break;
+                    case 2:
+                        if (touch_val_y) {
+                            ev.type = EV_KEY;
+                            ev.code = KEY_DOWN;
+                            ev.value = 1;
+                        }
+                        break;
+                    case 3:
+                        if (touch_val_y) {
+                            ev.type = EV_KEY;
+                            ev.code = KEY_ENTER;
+                            ev.value = 1;
+                        }
+                        break;
+                    case 4:
+                        if (touch_val_y) {
+                            ev.type = EV_KEY;
+                            ev.code = KEY_BACKSPACE;
+                            ev.value = 1;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+                touch_released = 0;
+            }
+    }
+#endif
+
     if (ev.type != EV_KEY || ev.code > KEY_MAX)
         return 0;
 
@@ -495,6 +631,136 @@ static void *input_thread(void *cookie)
     return NULL;
 }
 
+int get_battery_level(void) {
+    char buf[4];
+    char *str;
+    int fd;
+    int level;
+    ssize_t nbytes;
+
+    fd = open(BATTERY_LEVEL_FILE, O_RDONLY);
+    if (fd < 0)
+        return 0;
+
+    nbytes = read(fd, buf, sizeof(buf) - 1);
+    close(fd);
+    if (nbytes < 0)
+        return 0;
+    buf[nbytes] = '\0';
+
+    str = strndup(buf, nbytes);
+    level = atoi(str);
+
+    return level;
+}
+
+int battery_charging_usb(void) {
+    char buf[2];
+    char *str;
+    int fd;
+    int charging;
+    ssize_t nbytes;
+
+    fd = open(BATTERY_STATUS_CHARGING_FILE_USB, O_RDONLY);
+    if (fd < 0)
+        return 0;
+
+    nbytes = read(fd, buf, sizeof(buf) - 1);
+    close(fd);
+    if (nbytes < 0)
+        return 0;
+    buf[nbytes] = '\0';
+
+    str = strndup(buf, 1);
+    charging = atoi(str);
+
+    return charging;
+}
+
+int battery_charging_ac(void) {
+    char buf[2];
+    char *str;
+    int fd;
+    int charging;
+    ssize_t nbytes;
+
+    fd = open(BATTERY_STATUS_CHARGING_FILE_AC, O_RDONLY);
+    if (fd < 0)
+        return 0;
+
+    nbytes = read(fd, buf, sizeof(buf) - 1);
+    close(fd);
+    if (nbytes < 0)
+        return 0;
+    buf[nbytes] = '\0';
+
+    str = strndup(buf, 1);
+    charging = atoi(str);
+
+    return charging;
+}
+
+int command_update_leds(char *led_file, int value) {
+    char str[20];
+    int fd;
+    int ret;
+
+    fd = open(led_file, O_WRONLY);
+    if (fd < 0)
+        return 0;
+
+    ret = snprintf(str, sizeof(str), "%d", value);
+    ret = write(fd, str, ret);
+    close(fd);
+
+    if (ret < 0)
+       return 0;
+
+    return 1;
+}
+
+void update_leds(void) {
+    int level = get_battery_level();
+
+    int charging_usb = battery_charging_usb();
+    int charging_ac = battery_charging_ac();
+
+    int val = 255;
+    int val_thin = 122;
+    int val_off = 0;
+
+    int status;
+
+    if (level == 0)
+        level = 1;
+
+    if (charging_usb || charging_ac) {
+        if (level <= 95) {
+            status = command_update_leds(RED_LED_FILE, val);
+            status = command_update_leds(GREEN_LED_FILE, val_off);
+        } else if (level > 95 && level != 100) {
+            status = command_update_leds(RED_LED_FILE, val_thin);
+            status = command_update_leds(GREEN_LED_FILE, val_thin);
+        } else  {
+            status = command_update_leds(RED_LED_FILE, val_off);
+            status = command_update_leds(GREEN_LED_FILE, val);
+        }
+    } else {
+            status = command_update_leds(RED_LED_FILE, val_off);
+            status = command_update_leds(GREEN_LED_FILE, val_off);
+    }
+
+    return;
+}
+
+static void *leds_thread(void *cookie) {
+    for (;;) {
+        sleep(2);
+        update_leds();
+    }
+    return NULL;
+}
+
 void ui_init(void)
 {
     ui_has_initialized = 1;
@@ -589,6 +855,34 @@ void ui_init(void)
     pthread_t t;
     pthread_create(&t, NULL, progress_thread, NULL);
     pthread_create(&t, NULL, input_thread, NULL);
+    pthread_create(&t, NULL, leds_thread, NULL);
+#ifdef XPERIA_CWM_TOUCH
+    char buttonlights_command[100];
+#endif
+#ifdef XPERIA_GO
+#ifndef XPERIA_CWM_TOUCH
+    snprintf(buttonlights_command, sizeof(buttonlights_command), "/sbin/echo 255 > %s", BUTTON_BACKLIGHT);
+    __system(buttonlights_command);
+#endif
+    __system("/sbin/setprop ro.build.product lotus");
+#endif
+#ifdef XPERIA_SOLA
+#ifndef XPERIA_CWM_TOUCH
+    snprintf(buttonlights_command, sizeof(buttonlights_command), "/sbin/echo 255 > %s", BUTTON_BACKLIGHT);
+    __system(buttonlights_command);
+#endif
+    __system("/sbin/setprop ro.build.product pepper");
+#endif
+#ifdef XPERIA_P
+#ifndef XPERIA_CWM_TOUCH
+    snprintf(buttonlights_command, sizeof(buttonlights_command), "/sbin/echo 255 > %s", BUTTON_BACKLIGHT);
+    __system(buttonlights_command);
+#endif
+    __system("/sbin/setprop ro.build.product nypon");
+#endif
+#ifdef XPERIA_U
+    __system("/sbin/setprop ro.build.product kumquat");
+#endif
 }
 
 char *ui_copy_image(int icon, int *width, int *height, int *bpp) {
@@ -753,7 +1047,11 @@ void ui_printlogtail(int nb_lines) {
     ui_log_stdout=1;
 }
 
+#ifdef XPERIA_CWM_TOUCH
+#define MENU_ITEM_HEADER " "
+#else
 #define MENU_ITEM_HEADER " - "
+#endif
 #define MENU_ITEM_HEADER_LENGTH strlen(MENU_ITEM_HEADER)
 
 int ui_start_menu(const char** headers, char** items, int initial_selection) {
diff --git a/bootable/recovery/adefines.h b/bootable/recovery/adefines.h
new file mode 100644
index 0000000..d5d265d
--- /dev/null
+++ b/bootable/recovery/adefines.h
@@ -0,0 +1,45 @@
+#ifndef ADEFINES_H
+#define ADEFINES_H
+
+#if (defined XPERIA_GO || defined XPERIA_SOLA)
+#define HAVE_EXTERNAL_SDCARD
+#endif
+
+/* extendendcommands.c */
+#define BOARD_UMS_LUNFILE	"/sys/devices/virtual/android_usb/android0/f_mass_storage/lun/file"
+#define BOARD_VOLD_SDCARD_VOLUME_INT	"/dev/block/vold/179:14"
+#define BOARD_VOLD_SDCARD_VOLUME_EXT	"/dev/block/vold/179:97"
+
+#define VIBRATOR_TIMEOUT_FILE "/sys/class/timed_output/vibrator/enable"
+#define VIBRATOR_TIME_MS  10
+
+#define BATTERY_LEVEL_FILE  "/sys/devices/platform/ab8500-i2c.0/ab8500-fg.0/power_supply/ab8500_fg/capacity"
+#define BATTERY_STATUS_CHARGING_FILE_USB  "/sys/devices/platform/ab8500-i2c.0/ab8500-charger.0/power_supply/ab8500_usb/online"
+#define BATTERY_STATUS_CHARGING_FILE_AC  "/sys/devices/platform/ab8500-i2c.0/ab8500-charger.0/power_supply/ab8500_ac/online"
+
+/* comment to disable the installation animation */
+#define CWM_INST_ANIM
+
+#define BATTERY_LEVEL_FILE  "/sys/devices/platform/ab8500-i2c.0/ab8500-fg.0/power_supply/ab8500_fg/capacity"
+#define BATTERY_STATUS_CHARGING_FILE_USB  "/sys/devices/platform/ab8500-i2c.0/ab8500-charger.0/power_supply/ab8500_usb/online"
+#define BATTERY_STATUS_CHARGING_FILE_AC  "/sys/devices/platform/ab8500-i2c.0/ab8500-charger.0/power_supply/ab8500_ac/online"
+
+/* ui.c */
+#define USB_STATE_FILE "/sys/class/android_usb/android0/state"
+
+#if (defined XPERIA_GO || defined XPERIA_SOLA)
+#define RED_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0040/leds/red/brightness"
+#define GREEN_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0040/leds/green/brightness"
+#define BUTTON_BACKLIGHT "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0040/leds/button-backlight/brightness"
+#endif
+#ifdef XPERIA_P
+#define RED_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0036/leds/red/brightness"
+#define GREEN_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0036/leds/green/brightness"
+#define BUTTON_BACKLIGHT "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0036/leds/button-backlight/brightness"
+#endif
+#ifdef XPERIA_U
+#define RED_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0040/leds/pwr-red/brightness"
+#define GREEN_LED_FILE "/sys/devices/platform/nmk-i2c.2/i2c-2/2-0040/leds/pwr-green/brightness"
+#endif
+
+#endif
